### **1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.**
* 기본키(Primary key): 기본키는 관계형 데이터베이스에서 테이블의 모든 튜플을 고유하게 식별하는
속성 또는 속성 집합입니다. 즉, 기본키를 사용하면 테이블의 모든 레코드를 중복없이 구별 할수있습니다.
  * 특징
    * **고유성(Uniqueness)**:기본키 값은 테이블 내에서 고유해야합니다. 즉, 동일한 값을 가진 두개 이상의 레코드가 존재해서는 안됩니다.
    * **NULL 값 제한**: 기본키는 NULL 값이 허용되지 않습니다. 이는 모든 레코드가 기본키값을 가져아 합니다.
    * **검색 및 조인에 용이**: 기본키는 테이블 간의 관계를 설정하고 레코드를 식별하는데 사용됩니다. 이를 통해서 빠르고 효율적인 데이터 검색과 테이블간의 Join을 통해 원하는 값을 가져오기 용이합니다.
    * **테이블에 대한 유일한 식별자**: 기본키는 해당 테이블에서 유일한 식별자 역할을 합니다. 따라서 어떤 레코드도 기본키를 공유할수 없습니다.
    * **일반적으로 기본키를 인덱스 생성**: 많은 데이터베이스 관리 시스템에서는 기본키를 이용하여 자동으로 인덱스를 생성해 빠른 검색이 가능합니다.
    * **자동 증가(Auto-increment)**: 많은 경우, 기본키는 자동으로 증가하는 값을 가집니다. 이는 주로 숫자형 데이터 타입에 해당되며, 새로운 레코드가 추가될때마다 기본키 값이 자동으로 증가하여 고유성을 유지합니다.
* 후보키(Candidate Key): 후보키는 관계형 데이터베이스에서 튜플들을 유일하게 식별할수있는 키(Key)의 하나입니다. 기본키로 선택될 수도 있는 키가 후보키입니다. 테이블에는 하나 이상의 후보키가 존재할수있습니다.
  * **기본키와 다른점**: NULL값을 허용할수있고, 변경 가능성이 비교적 높으며, 테이블에서 여러개로 선택될수있습니다.
  * 특징
    * **유일성**: 모든 레코드는 서로 다른 후보키 값을 가져야합니다. 즉, 두개의 레코드가 동일한 후보키값을 가질수 없습니다.
    * **최소성**: 후보키를 구성하는 속성 중 하나라도 제거하면 더 이상 모든 레코드를 유일하게 식별할 수 없습니다.
  * 후보키를 세팅할시 주요 이점
    * **고유성 보장**: 후보키를 통해 테이블 내의 레코드를 고유하게 식별할수있습니다. 이를 통해 데이터 일관성을 유지합니다.
    * **데이터 무결성 유지**: 후보키를 통해 데이터 무결성을 유지할수있습니다. 즉, 잘못된 데이터가 테이블에 삽입되는것을 방지할수있습니다.
    * **검색 및 조작 성능 향상**: 후보키에 대한 인덱스를 생성하면 검색 및 조작 작업의 성능이 향상될수 있습니다.
    * **데이터베이스 설계의 명확성**: 후보키를 정의하면 데이터베이스 구조가 명확해지고 이해하기 쉬워집니다. 후보키를 통해 데이터의 구성 요소와 관계를 이해하고 관리할수 있습니다.
* 대리키(Alternate Key): 대리키는 관계형 데이터베이스의 관계 모델에서 관계의 '후보키'중 기본 키로 선정되지 않은 키를 말합니다.
* 슈퍼키(Super Key): 슈퍼키는 테이블 내의 모든 레코드를 고유하게 식별할수있는 속성 또는 속성 집합입니다. 즉, 슈퍼키는 후보키와 기본키의 상위 개념입니다. 슈퍼키는 후보키와 비슷한 개념이지만, 후보키보다 더 일반적인 개념입니다.
후보키는 유일성과 최소성의 조건을 모두 만족하는 슈퍼키의 특별한 경우입니다. 따라서 모든 후보키는 슈퍼키지만, 모든 슈퍼키가 후보키는 아닙니다.
  * 특징
    * **고유성(Uniqueness)**: 슈퍼키는 테이블 내의 모든 레코드를 고유하게 식별할수있습니다.
    * **최소성(Minimality)**: 슈퍼키를 구성하는 속성 중 하나라도 제거하면 더 이상 모든 레코드를 고유하게 식별할수 없습니다.
* 외래키(Foreign Key): 외래키는 관게형 데이터베이스에서 한 테이블의 필드가 다른 테이블의 기본키(Primary Key)를 참조하는 특별한 종류의 제약 조건입니다. 이를 통해 테이블 간의 관계를 설정하고 유지할 수 있습니다.
  * 특징
    * **참조 관계 설정**:외래 키는 다른 테이블의 기본 키 또는 유일 키를 참조합니다.
    * **무결성 제약 조건**: 외래키 제약은 데이터 무결성을 유지하는 데 중요한 역할을 합니다. 외래키를 통해 참조하는 테이블의 값은 반드시 참조되는 테이블의 주키와 일치해야 합니다. 이를 통해 부모 테이블에서 삭제되거나 수정되는 데이터에 대한 정합성을 보장할 수 있습니다.
    * **다양한 연산**: 외래키는 다양한 연산에 활용될 수 있습니다. 주로 데이터 검색, 조인 작업, 그리고 데이터의 관련성을 유지하는 데 사용됩니다.
    * **테이블 간의 관계 정의**: 외래키는 테이블 간의 관계를 명시적으로 정의하는 데 사용됩니다. 이를 통해 데이터베이스의 구조를 이해하고 쿼리를 작성할 때 테이블 간의 연관성을 파악할 수 있습니다. 예를 들어 두 테이블간의 1:N 또는 N:N 관계를 정의합니다.
  * 예시
    *  주문 테이블
    * | 주문번호 | 고객번호    | 상품 |
      |---|---------|---|
      | 1 | **100** | 컴퓨터 |
      | 2 | **200** | 스마트폰 |
      | 3 | **100** | 책 |
    * 고객 테이블
    * | 고객번호    | 이름 | 주소 |
      |---------|---|---|
      | **100** | 홍길동 | 서울 |
      | **200** | 김철수 | 부산 |
      | **300** | 이영희 | 대구 |
    * 주문 테이블의 고객번호 속성은 고객 테이블의 고객번호 속성을 참조하는 외래 키입니다.

- **기본키는 수정이 가능한가요?**
- **사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?**
- **외래키 값은 NULL이 들어올 수 있나요?**
- **어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?**

### **2. RDB와 NoSQL의 차이에 대해 설명해 주세요.**

- **NoSQL의 강점과, 약점이 무엇인가요?**
- **RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)**
- **NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.**

### **3. 트랜잭션이 무엇이고, 3.ACID 원칙에 대해 설명해 주세요.**

- **ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?**
- **트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?**
- **읽기에는 트랜잭션을 걸지 않아도 될까요?**

### **4. 트랜잭션 격리 레벨에 대해 설명해 주세요.**

- **모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?**
- **만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.**
- **그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?**

### **5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.**

- **일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?**
- **앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?**
- **ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.**
- **기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?**
- **그렇다면 외래키는요?**
- **인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?**
- **우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?**
- **(A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?**

### **6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.**

- **이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?**
- **마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?**
- **다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.**
- **샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?**

### **7. 정규화가 무엇인가요?**

- **정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.**
- **각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.**
- **정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.**

### **8. View가 무엇이고, 언제 사용할 수 있나요?**

- **그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?**

### **9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.**

- **사실, JOIN은 상당한 시간이 걸릴 수 있기에 내부적으로 다양한 구현 방식을 사용하고 있습니다. 그 예시에 대해 설명해 주세요.**
- **그렇다면 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?**
- **앞 질문들을 통해 인덱스의 중요성을 알 수 있었는데, 그렇다면 JOIN의 성능도 인덱스의 유무의 영향을 받나요?**
- **3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하는지, 그리고 그 방식이 성능에 어떠한 영향을 주는지 설명해 주세요.**

### **10. B-Tree와 B+Tree에 대해 설명해 주세요.**

- **그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?**
- **DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?**
- **오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.**

### **11. DB Locking에 대해 설명해 주세요.**

- **Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.**
- **물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?**

### **12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?**

- **DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?**

### **13. Schema가 무엇인가요?**

- **Schema의 3계층에 대해 설명해 주세요.**

### **14. DB의 Connection Pool에 대해 설명해 주세요.**

- **DB와 Client가 Connection을 어떻게 구성하는지 설명해 주세요.**

### **15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.**

- **가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?**
- **COUNT (개수를 세는 쿼리) 는 어떻게 동작하나요? COUNT(1), COUNT(\*), COUNT(column) 의 동작 과정에는 차이가 있나요?**

### **16. SQL Injection에 대해 설명해 주세요.**

- **그렇다면, 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?**
