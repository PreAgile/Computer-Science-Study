## Java

<details>
<summary>📚 공부한 자료</summary>

- 자바의 정석

</details>

### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.

JVM이란 _Java 언어와, Java bytecode 로 컴파일 된 다른 언어들도 실행할 수 있게 해주는 환경을 만들어주는 가상 머신_ 입니다. 프로그래머가 작성한 언어를 컴퓨터가 이해하고 실행하기 위해서는 기계어로 컴파일 해야 합니다. Java(\*.java) 를 Java bytecode(\*.class) 로 컴파일 하는 것은 java compiler 가 합니다. Java bytecode 를 실제 기계어로 해석하는 일을 JVM 이 담당합니다.

- **그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?**
  - 있습니다. JVM 은 Java bytecode를 인식합니다. 즉, Java bytecode 로 컴파일 될 수 있는 다른 언어들도 실행할 수 있습니다. 대표적으로는 Scala, Groovy, Kotlin 등이 있습니다.
- **반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?**
  - JVM 계열 언어도 직접 기계어로 변환해서 사용할 수 있습니다. 일부 JVM 구현체는 Ahead-Of-Time(AOT) 컴파일을 지원하여, 바이트코드를 실행 전에 기계어로 미리 컴파일할 수 있습니다.
- **VM은 어떤 것인가요?**
  - 가상머신은 물리적 컴퓨터의 디지털 버전입니다. 즉, 물리적 컴퓨터와 동일한 기능을 제공하지만, 소프트웨어 형태로 제공됩니다. 가상 머신에는 물리적 컴퓨터와 마찬가지로 자체 운영체제(Windows, Linux 등), 스토리지, 네트워킹 및 어플리케이션이 포함되어 있습니다. 하이퍼바이저가 가상 머신을 생성하고 실행하는 프로세스인데, 하이퍼바이저는 메모리 및 처리와 같은 단일 호스트 컴퓨터의 리소스를 가상으로 공유하여 호스트 컴퓨터위에서 여러 개의 가상 머신을 사용할 수 있게 합니다.
- **VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.**
  - 우선 가상머신을 사용하면, 플랫폼에 독립될 수 있습니다. 예를 들어, JVM 위에서 실행되는 Java 어플리케이션은 어떤 운영체제 위에서도 실행될 수 있습니다. 하지만 단점으로는, 가상 머신은 네이티브 호스트 상에서 실행할 때보다 추상화 계층이 도입되므로, 네이티브 실행 시에 비해 오버헤드가 발생할 수 있습니다.
- **JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?**
  - 전통적인 의미의 "부모 프로세스-자식 프로세스" 로 보는 것은 정확하지 않습니다. JVM이 실행될 때, 운영체제는 JVM을 위한 프로세스를 생성합니다. 이 JVM 프로세스 내에서 자바 프로그램이 실행되며, 이것은 운영체제에 의해 별도의 자식 프로세스가 생성되는 것이 아닌 JVM 프로세스의 일부로 실행됩니다. 따라서 JVM 내부에서 실행되는 자바 프로그램은 JVM 프로세스의 스레드로서 작동합니다.
- **Java bytecode란 무엇인가요?**
  - Java bytecode 란 JVM 이 이해할 수 있는 언어로 변환된 자바 소스코드입니다. Java 컴파일러에 의해 변환된 코드의 명령어 크가 1 byte 라서 바이트 코드라고 불립니다.
- **그렇다면 Java는 컴파일 언어일까요, 인터프리터 언어일까요?**
  - 자바는 컴파일, 인터프리터 방식 모두 사용합니다. 우선 자바 컴파일러가 자바 바이트코드 로 컴파일 한다는 면에서 컴파일 언어의 특성을 가지고 있습니다. 하지만 자바 바이트코드는 JVM의 자바 인터프리터가 한 줄씩 읽으면서 컴퓨터가 이해할 수 있는 바이너리 코드로 번역한 후 실행합니다. 이 부분은 인터프리터 언어의 특성을 가지고 있다고 볼 수 있습니다. 따라서 자바는 하이브리드 언어라는 이름으로 불립니다.
- **JVM의 구조에 대해 설명해주세요.**

  <details>
  <summary>JVM 구조</summary>

  - JVM

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/2b417674-9775-408c-8bc5-25b877639daf)

  - Class Loader

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/cbdce3f2-d119-4548-98ff-1b4bd55137cb)

  - Execution Engine

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/ff138ec5-9227-4af8-8f03-aa79ade86093)

  - 출처 : [JVM 내부 구조 & 메모리 영역 💯 총정리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-JVM-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD-%EC%8B%AC%ED%99%94%ED%8E%B8)

  </details>

  - JVM의 구조는 크게 Class Loader, Runtime Data Area, Execution Engine, 영역으로 나눌 수 있습니다.
  - **Class Loader**
    - 3가지 단계 (Loading, Linking, Initialization) 으로 구성됩니다.
    - 우선 자바 컴파일러를 통해서 .class 확장자를 가진 클래스 파일은 각 디렉토리에 흩어져 있고, 기본적인 라이브러리들의 클래스 파일은 $JAVA_HOME 내부 경로에 존재합니다. 각각의 클래스 파일을 찾아서 JVM의 메모리 영역인 Runtime Data Areas 에 로드해주는 역할을 합니다. 두번째로는 로드된 클래스를 검증하고 기본값으로 초기화하는 링킹 과정도 합니다. 세번째로는 static field 의 값들을 정의한 값으로 초기화하는 과정도 합니다.
  - **Execution Engine**

    - 실행 엔진은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행합니다.이 과정에서 실행엔진은 인터프리터와 JIT 컴파일러 두 가지 방식을 혼합하여 바이트 코드를 실행합니다. 기본적으로는 **인터프리터 방식**인데, 바이트코드를 한 줄마다 읽어서 해석하고 바로 실행합니다. 하지만 여러 번 호출되면 매번 해석하고 수행하는 과정은 번거롭기 때문에 반복되는 코드는 바이트 코드 전체를 컴파일하여 기계어로 번역하고 해당 메서드는 캐싱해 두었다가 바로 실행하는 **JIT 컴파일러 방식**도 같이 사용합니다.
    - 실행 엔진에는 Garbace Collector(GC) 도 포합되어 있습니다. GC는 JVM 상에서 더 이상 사용되지 않는 데이터가 할당되어있는 메모리를 해제시켜주는 장치입니다. GC가 동작하는 대상은, Heap 영역 내의 객체 중 참조되지 않는 데이터 입니다. GC가 주로 heap 영역을 대상으로 하는 이유는, heap 영역은 모두 공유되기 때문에, 하나의 메소드가 종료되어도 heap 영역의 데이터를 함부로 삭제할 수 없기 때문입니다. GC가 실행될때는 GC를 담당하는 쓰레드를 제외한 모든 쓰레드들은 작동이 일시적으로 정지되게 하는 Stop-the-World 현상이 발생합니다. 따라서 모든 쓰레드가 정지되기 때문에 성능이 저하됩니다. 그래서 적절한 빈도의 GC가 실행되도록 하는 점이 중요합니다.

- **JVM의 Runtime Data Area 영역은 무엇인가요?**
  <details>
  <summary>JVM Runtime Data Area </summary>

  ![image](https://github.com/ddoddii/Computer-Science-Study/assets/95014836/9c92bb22-9439-4bf5-a40d-a332af92ed0a)

  - [JVM에 관하여 - Part 3, Run-Time Data Area](https://tecoble.techcourse.co.kr/post/2021-08-09-jvm-memory/)
  - [Chapter 2. The Structure of the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se19/html/jvms-2.html#jvms-2.5.4)
  </details>

  - JVM Runtime Data Area 에는 크게 Method Area, Heap, JVM Stacks, Native Method Stacks, PC registers 가 존재합니다. Method Area, Heap 영역은 모든 쓰레드가 공유하고, JVM Stacks, PC registers ,Native Method Stacks 는 쓰레드 별로 생성되고 해당 쓰레드가 종료될 때 소멸됩니다.
  - **Method Area**는 정적 영역이라고 부르는 메모리입니다. Method Area 는 JVM 이 시작될 때 생성됩니다. Method area 는 OS 프로세스의 '텍스트' 영역과 유사합니다. 여기에는 run-time constant pool, 필드와 메서드 데이터, 메서드와 생성자를 위한 코드(클래스와 인스턴스 초기화에서 사용되는 스페셜 메서드) 를 저장합니다.
  - 여기에는 클래스와 인터페이스의 바이트코드 및 메타 데이터가 저장됩니다.
  - **Heap** 영역은 클래스 인스턴스와 배열들이 저장되는 장소입니다. Heap 영역도 JVM이 시작될 때 생성됩니다. Heap 영역에 있는 오브젝트들은 명시적으로 할당 해제되지 않으며, GC에 의해 회수됩니다.
  - 각 JVM 스레드에는 스레드와 동시에 생성된 각자의 **JVM stack** 이 있습니다. JVM stack 는 프레임들을 저장하고, C 언어와 비슷하게 지역 변수와 부분 결과를 보유하고, 메서드 호출 및 반환에 역할을 합니다.
  - **Native Method Stacks**는 JVM stack 과 비슷한 데이터들을 저장하지만, 자바가 아닌 다른 언어로 작성된 네이티브 메서드를 실행할 때 사용됩니다.
  - 스레드는 각자의 메서드를 실행합니다. 이때, 스레드 별로 동시에 실행하는 환경이 보장되어야 하므로 최근에 실행 중인 JVM에서는 명령어 주소값을 저장할 공간이 필요합니다. 이 부분을 **PC registers**가 관리하고 추적합니다. 즉, PC register 는 JVM에서 사용되었던 명령어 주소 값을 저장합니다.

- **Frame 은 무엇인가요?**
  - Frame 은 데이터와 부분적인 연산 결과 뿐만 아니라 다이나믹 링킹, 메서드의 리턴 값 및 예외를 저장하는데 사용됩니다. 메서드를 호출할 때마다 새 프레임이 만들어집니다. 그리고 메서드 호출이 완료되면(정상적으로 종료되거나 예외를 반환하거나 둘다의 경우) 프레임이 파괴됩니다. 프레임은 해당 프레임을 생성하는 스레드의 JVM stack 에서 할당됩니다.각 프레임은 고유한 지연 변수 배열, 피연산자 스택, 현제 메서드 클래스의 런타임 상수 풀에 대한 참조가 있습니다.
- **Runtime constant pool 에는 어떤 것이 저장되어 있나요?**
  - Class file constant pool에서 읽어온 값들이 저장됩니다. 이것은 컴파일 시 클래스파일 내부에 존재하는 영역으로, 클래스 로더에 의해 JVM에 로드될 때 메모리에 로드합니다. 주로 클래스의 구성요소(상수,문자열,클래스/인터페이스 참조) 데이터를 저장하고 있습니다.
  - 주로 클래스와 관련된 메타데이터를 저장하고, 클래스 구조, 필드, 메서드와 같은 데이터를 저장합니다.
- **JIT, JVM, JDK, JRE 는 각각 무엇이고, 어떤 용도인가요?**
  - JIT(Just-In-Time Compiler) : JVM의 일부로, 자바 바이트코드를 더 빠르게 기계어로 번환하는 역할을 합니다. 프로그램 실행 시간에 바이트코드를 기계어로 컴파일합니다.
  - JVM : 자바 바이트코드를 실행하는 가상 머신입니다.
  - JDK(Java Development Kit) : 자바 프로그램을 개발할 때 필요한 환경입니다. 컴파일러(javac), 자바 실행 환경(JRE), 클래스 라이브러리들, 도구들(예: 디버거, 자바독) 등 개발에 필요한 여러 도구와 라이브러리를 포함합니다.
  - JRE(Java Runtime Environment) : 자바 어플리케이션을 실행하기 위해 필요한 환경입니다. JVM, 라이브러리 클래스, 자바 애플리케이션을 실행하기 위해 필요한 기타 파일들을 포함합니다.
- **Java 메모리 영역 중 Stack 과 Heap 에는 각각 어떤 것이 저장되나요?**
  - 자바에서 stack 영역은 스레드마다 하나씩 존재하며, 스레드 내에서 실행되는 각 메서드 호출 정보에 대한 정보를 저장하는 공간입니다. 메서드가 호출될 때마다 해당 메서드를 위한 프레임이 스택에 추가(push) 되며, 메서드가 종료될 때 해당 프레임은 스택에서 제거(pop) 됩니다. 프레임 내에는 지역 변수, 매개 변수, 연산 중간 결과와 같은 값들이 저장되어 있습니다.
  - Heap 영역은 JVM 전체에서 공유되는 메모리 영역으로, 모든 스레드가 접근할 수 있습니다. 자바에서 동적으로 할당된 객체와 배열이 이 영역에 할당됩니다. 즉, `new` 키워드를 사용해서 생성된 모든 객체와 배열이 여기에 저장됩니다. Heap 영역은 가비지 컬렉터(Garbage Collector)에 의해 관리되며, 더 이상 참조되지 않는 객체들은 가비지 컬렉터에 의해 자동으로 메모리에서 제거됩니다.
- **기본형 데이터 타입과 참조형 데이터 타입의 실제 값은 각각 어느 영역에 저장되나요?**
  - 기본 데이터 타입 변수(ex. int, float, boolean..) 는 실제 값이 스택 영역에 저장되고, 참조 타입 변수는 실제 객체의 값은 heap 영역에 저장되지만 해당 객체를 가리키는 참조 값(메모리 주소)는 스택 프레임 내 저장됩니다.
- **Java 메모리의 있는 스택 프레임은 메서드가 종료되면 사라집니다. 하지만 힙 영역에 있는 객체들은 메서드가 종료되도 메모리에 남아 있습니다. 왜 그럴까요?**
  - 객체가 메서드 종료 후에도 메모리에 남아 있는 이유는 객체의 생명주기가 해당 객체를 생성한 메서드의 생명주기와 독립적이기 때문입니다. 객체는 힙 영역에 저장되며, 이 영역은 JVM 내 다른 스레드에서도 접근할 수 있습니다. 객체가 어떤 메서드에서 생성되었더라도, 다른 메서드에서 이 객체에 대한 참조를 가지고 있다면, 그 객체는 여전히 유효하고 접근 가능합니다. 따라서 객체의 생명은 참조가 있는 동안 계속되며, 모든 참조가 사라지고 나서야 GC에 의해 메모리에서 제거될 수 있습니다.

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?

`final` 키워드는 자바에서 변수, 메서드, 클래스에 대한 변경을 제한하기 위해 사용됩니다.

- 변수에 `final` 이 사용되는 경우

  - `final` 변수는 멀티스레드 환경에서 공유될 때 추가적인 동기화 없이도 작업이 안전하다는 것을 보장합니다. (thread-safe)
  - 원시 변수에 `final` 로 선언하면 한번 초기화된 변수는 변경할 수 없는 상수값이 됩니다. (`final int x = 1`)
  - 객체 변수에 `final` 로 선언하면, 그 변수에 다른 참조 값을 지정할 수 없습니다. 단, 객체 자체가 immutable 하다는 의미는 아니며, 객체의 속성은 변경 가능합니다.

  ```java
      public void test_final_reference_variables() {
        final Pet pet = new Pet();
        // pet = new Pet(); //다른 객체로 변경할수 없음

        pet.setWeight(3); //객체 필드는 변경할 수 있음

    }
  ```

- 메서드에 `final` 이 사용되는 경우
  - `final` 로 선언된 메서드는 하위 클래스에서 오버라이드할 수 없습니다. 따라서 `final` 로 선언된 메서드는 컴파일 시점에 어느 클래스가 실행될 지 알 수 있으며, 정적 디스패치가 가능하여, 동적 디스패치보다 실행 시간을 단축할 수 있습니다.
- 클래스에 `final` 이 사용되는 경우

  - `final` 로 선언된 클래스는 상속될 수 없습니다. 이는 컴파일러가 클래스의 모든 메서드를 자동으로 `final` 메서드로 취급할 수 있게 합니다.

- **그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?**
  - `final`로 선언된 변수가 컴파일 시점에 리터럴 값으로 초기화된 경우, 컴파일러는 이 변수를 상수로 취급하고 해당 변수가 사용된 모든 위치를 실제 값으로 대체할 수 있습니다.
  - `final` 로 선언된 메서드는 오버라이딩이 불가능하기 때문에, 컴파일러와 JVM은 이 메서드를 호출하는 부분에 메서드의 본문을 직접 삽입하는 최적화(인라이닝)을 수행할 수 있습니다. 이는 메서드 호출에 대한 오버헤드를 줄이고 성능을 향상시킵니다.
  - `final` 로 선언된 클래스는 상속될 수 없으므로, 컴파일러는 `final` 클래스의 모든 메서드들을 자동으로 `final` 취급합니다. 따라서 클래스와 관련된 다이나믹 디스패치가 필요 없으므로 컴파일러는 더 효율적인 코드를 생성할 수 있습니다.

### 3. 변수는 어떤 것인가요?

변수란 단 하나의 값을 저장할 수 있는 메모리 공간입니다. 변수를 사용하려면 변수를 선언하고, 변수를 초기화해야 합니다. 변수의 자료형에는 크게 기본형(primitive), 참조형(reference) 두 가지로 나눌 수 있는데, 기본형 변수는 실제 값을 저장하는 반면, 참조형 변수는 어떤 값이 저장되어 있는 주소를 값으로 갖습니다. 기본형 변수에는 논리형(boolean), 문자형(char), 정수형(byte,short,int,long), 실수형(float,double) 이 있습니다.

- **참조형 변수에서 실제 값을 저장하지 않고 주소값을 저장하는 이유는 무엇인가요?**

  - 참조형 변수에서 참조값은 각 스레드 내의 스택 영역에 저장되고, 실제 객체 데이터는 JVM내 스레드들이 공유하는 힙 영역에 저장됩니다. 이때 객체 데이터의 크기는 매우 클 수 도 있고, 데이터의 크기는 변화할 수 있습니다. 따라서 메모리 주소만 저장함으로써 메모리 사용을 더욱 효율적으로 관리할 수 있습니다. 또한 참조를 통해 여러 변수가 동일한 객체를 가리킬 수 있으므로, 데이터가 중복되어 저장되는 것을 방지합니다.

- **그렇다면 기본형 변수는 스택 영역 내에 실제 값을 저장하는 이유는 무엇인가요?**

  - 기본형 변수는 고정된 크기를 가지며, 이들의 처리는 참조형 변수에 비해 상대적으로 단순하고 빠릅니다. 스택 영역은 메서드 호출과 함께 실행 컨텍스트를 저장하는 공간입니다. 여기에 저장된 변수는 메서드 실행 동안 빠르게 접근되고, 메서드 종료 시 함께 소멸되므로 메모리 관리가 효율적입니다. 또한 기본형 변수는 고정된 크기를 사용하므로, 스택에 할당하기 적합합니다.

- **변수와 상수의 차이는 무엇인가요?**
  - 변수와 상수는 데이터를 저장하는 컨테이너라는 공통점이 있지만, 그 값을 변경할 수 있는지 여부에 따라 차이가 있습니다. 프로그램 실행 중에 변수에 저장된 값은 변경될 수 있습니다. 변수는 프로그램이 실행되는 동안 정보를 저장하고, 수정하며, 참조하기 위해 사용됩니다. 반면 상수는 한 번 값이 할당되면 프로그램 실행 도중 그 값이 변경될 수 없는 메모리 공간입니다. 자바에서는 `final` 키워드를 통해 상수를 선언합니다.

### 4. 부동소수점이 무엇인가요?

컴퓨터에서 실수를 표현하는 방식으로는 대표적으로는 고정 소수점 방식(fixed-point number representation) 과 부동 소수점 방식(floating-point number representation) 으로 나눌 수 있습니다. 자바의 float 타입을 기준으로, 실수 메모리는 총 32비트를 할당받습니다. 부동소수점은 정수부, 소수부가 16비트로 나누어져 있는 고정 소수점 방식과 달리 메모리를 가수부(23bit)와 지수부(8bit)로 나눕니다. 가수부에는 실제 실수 데이터 비트들이 들어가고, 지수부에는 소수점의 위치를 가리키는 제곱승이 들어갑니다. 따라서 부동소수점을 사용하면 더 큰 범위의 값을 표현할 수 있습니다.

- **부동소수점을 사용하면, 소수 계산 오차 문제가 사라지나요?**

  - 아닙니다. 0.625 같이 이진수 소수점으로 딱 떨어지는 수 도 있지만, 0.1과 같이 무한 반복되는 이진수 실수는 아무리 큰 수를 저장하는 부동소수점 방식이라 하더라도 무한대를 저장할 수 없으므로 메모리 한계까지 소수점을 집어넣고 어느 부분에서 끊어 반올림을 해주어야 합니다. 이를 무한 소수라고 합니다. 이러한 무한 소수 때문에 부정확한 실수의 계산결과가 생기게 됩니다.

- **자바에서 실수형 계산을 정확하게 하기 위해서는 어떻게 해야 하나요?**
  - 자바에서는 2가지 방법을 제공하는데, 첫번째는 int,long 정수형 타입으로 치환하고 사용하는 방법과 두번째는 BigDecimal 클래스를 이용하는 방법입니다.
  - 첫번째 방법은 예를 들어 23.25에 100을 곱해서 2535로 정수로 치환해서 계산하고 다시 100으로 나누는 방법입니다.
  - 첫번째 방법으로는 소수의 크기가 18자리를 초과하는 경우 int,long 타입으로 표현할 수 없기에 BigDecimal 클래스를 사용해야 합니다. BigDecimal 타입은 내부적으로 수를 십진수로 저장하여 아주 작은 수와 아주 큰 수의 연산에 대해 무한한 정밀도를 보장합니다.

### 5. `==` 과 `equals` 의 차이점은 무엇인가요?

- `==` 연산자

  - 기본형 데이터 비교: `==` 연산자는 기본형 데이터의 값을 직접 비교할 때 사용됩니다. 예를 들어 int,char,float 등의 타입에 대해 `==` 를 사용하면, 두 변수의 저장된 값이 같은지 확인합니다.
  - 참조형 데이터 비교: 참조형 데이터에 대해 `==` 를 사용하면, 두 객체의 메모리 주소를 비교합니다. 즉, 두 참조가 실제로 동일한 객체를 가리키고 있는지 확인합니다. 두 객체가 내용적으로 동일하더라도, 다른 메모리 주소에 할당된 경우 `==` 는 `false` 를 반환합니다.

- `equals()` 메서드

  - `equals()` 메서드는 객체의 내용 자체를 비교하는 데 사용됩니다. `Object` 클래스에서 상속받은 `equals()` 메서드는 기본적으로 `==` 연산자와 동일하게 객체의 참조를 비교합니다. 하지만, 대부분의 클래스 (String, Integer 등 자바 표준 클래스) 에서는 `equals()` 메서드를 오버라이드하여 객체의 내용을 비교하도록 구현합니다. 이렇게 오버라이드된 `equals()` 메서드는 두 객체의 실제 데이터 값을 비교하여, 내용이 같다면 `true`를 반환합니다.

- **Object 의 `equals` 메서드는 어떻게 구현되어 있나요?**

  ```java
  // Object equals() 메서드
  public boolean equals(Object obj) {
    return (this == obj);
  }
  ```

  - Object 의 `equals()` 메서드는 두 참조가 실제로 같은 객체를 가리키는지 확인합니다. 이 기본 구현은 참조 동등성만 고려하기 때문에, 객체의 논리적 동등성(logical equality)를 비교하려면 `equals()` 메서드를 오버라이드 해야 합니다.
  - 예를 들어 **String** 클래스에서는 `equals()` 메서드를 아래와 같이 오버라이드 하여 문자열의 내용이 같은지 비교합니다. 첫번째로 현재 객체(`this`) 와 비교 대상 객체(`anObject`) 의 참조를 비교해서 같은 메모리 주소를 가리키면 `true` 를 반환합니다. 만약 메모리 주소가 같지 않더라도, 논리적 동등성을 확인합니다. 우선 `anObject instanceof String aString` 부분은 `anObject` 가 `String` 타입인지 확인하고, 현재 문자열과 비교 대상 문자열의 내부 표현 방식(`coder`)이 같은지 비교합니다. 마지막으로 `StringLatin1.equals(value, aString.value)` 를 통해 두 문자열이 같은 값을 가지고 있는지 확인합니다.

    ```java
    // String equals() 메서드
    public boolean equals(Object anObject) {
          if (this == anObject) {
              return true;
          }
          return (anObject instanceof String aString)
                  && (!COMPACT_STRINGS || this.coder == aString.coder)
                  && StringLatin1.equals(value, aString.value);
      }
    ```

  - Integer 클래스에서는 `equals()` 메서드를 아래와 같이 오버라이드 하여 Integer 객체 내부 값이 같은지 비교합니다.

    ```java
    // Integer equals() 메서드
    public boolean equals(Object obj) {
      if (obj instanceof Integer) {
          return value == ((Integer)obj).intValue();
      }
      return false;
    }
    ```

- **아래의 코드는 어떤 결과가 나올까요? 이유를 설명해보세요.**

  ```java
  Integer a = new Integer(3);
  Integer b = new Integer(3);
  System.out.println(a==b);
  ```

  - 위의 코드는 `false` 를 반환합니다. `==` 연산자는 두 객체의 참조를 비교합니다. 즉, 두 객체가 메모리 상에서 같은 위치를 가리키는지 확인합니다. 코드에서 `a` 와 `b` 는 `Integer` 클래스의 인스턴스이며, `new Integer(3)` 을 통해 각각 생성됩니다. `new` 키워드를 사용하면 자바 힙 메모리에 새로운 객체가 할당됩니다. 따라서 `a`,`b` 는 내용은 같지만 실제로는 메모리 상의 서로 다른 위치에 있는 별개의 객체입니다.

- **그럼, `equals()` 와 `hashCode()` 에 대해 설명해 주세요.**

  - `hashCode()` 메서드는 객체의 주소값을 이용해서 해싱 기법을 통해 해시 코드를 만든 후 반환합니다. 그렇기 때문에 서로 다른 두 객체는 같은 해시 코드를 가질 수 없게 됩니다.

- **본인이 `hashCode()` 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?**

  - 자바에는 `equals()` 의 결과가 `true` 인 두 객체의 해시코드는 반드시 같아야 한다는 규칙이 있습니다. 따라서 `equals()` 를 오버라이딩 했다면, `hashCode()` 도 오버라이딩 해야 합니다. 두 메서드를 같이 재정의하지 않을 시, hash 값을 이용하는 Collection Framework (HashSet, HashMap, HashTable) 을 사용할 때 문제가 생깁니다.
  - 조금 더 자세히 설명하자면, `hashCode()` 와 `equals()` 의 동작 순서를 알아야 합니다. 우선 컬렉션에 데이터를 추가할 때, 그 데이터의 `hashCode()` 리턴 값을 컬렉션이 가지고 있는지 비교합니다. 만일 해시코드가 같다면 그제서야 다음으로 `equals()` 메서드의 리턴값을 비교하게 되고, true 이면 논리적으로 같은 객체라고 판단합니다. 만약 `equals()`만 재정의하고 `hashCode()`를 재정의하지 않는다면, `hashCode()` 의 결과상으로는 다른 객체로 판별되므로, 같은 값을 가지고 있는 객체라고 해도 hashSet 에 두 번 추가 되는 문제가 생깁니다.

- **그렇다면 `equals()` 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.**

  - `equals()` 를 재정의 할 때, 다음의 순서대로 재정의합니다.
  - 순서1. 두 객체가 동일한 참조 값을 가지는지 확인합니다. 둘 다 동일한 참조 값을 가지는 경우 데이터도 동일하므로 true 를 반환하도록 합니다.
  - 순서2. 매개변수로 전달받는 객체가 null 이거나 두 객체가 동일한 타입이 아니라면, false 를 반환하도록 합니다.
  - 순서3. 매개변수로 전달받은 매개변수를 현재 클래스 타입으로 반환합니다.
  - 순서4. 모든 필드의 값을 비교합니다. 기본 타입이라면 `==` 연산자를 사용하고 참조 타입인 경우 Objects 클래스의 `equals()` 메서드를 사용할 수 있습니다.

- **만약 `equals()` 와 `hashCode()` 를 둘 다 재정의 했을 때, 객체의 주소값을 비교해야 한다는 상황이 온다면 어떻게 하나요?**
  - 자바에서는 똑같이 해시코드를 반환해주는 또 다른 메서드인 `identityHashCode()` 가 있습니다. 만약 `hashCode()` 를 오버라이딩 해서 쓰는데, 오버라이딩 하기 전의 원조 기능이 필요할때 사용 하는 메서드입니다.

### 6. 다형성은 무엇인가요? 또 언제 활용할 수 있을까요?

다형성은 객체 지향 프로그래밍의 핵심 원리 중 하나로, "많은 형태를 가질 수 있는 능력"을 의미합니다. 다형성은 같은 인터페이스나 메서드 호출이지만, 다양한 객체애 대해 다른 방식으로 작동할 수 있게 해줍니다. 자바에서 다형성은 주로 상속과 인터페이스를 통해 구현됩니다.

다형성은 두 가지 주요 형태로 나타납니다.

- 컴파일 타임 다형성(정적 다형성) : 메서드 오버로딩을 통해 구현됩니다. 이는 같은 클래스 내에서 메서드 이름이 같지만, 매개변수의 타입이나 개수가 다른 여러 메서드를 정의할 수 있게 해줍니다. 컴파일러는 메서드를 호출때 제공된 인자에 기반하여 어떤 메서드를 사용할 지 결정합니다.
- 런타임 다형성(동적 다형성) : 상속과 인터페이스를 활용한 메서드 오버라이딩을 통해 구현됩니다. 상위 클래스 또는 인터페이스 타입의 참조 벼수가 다양한 하위 클래스의 객체를 참조할 수 있으며, 실행 시간에 어떤 클래스의 메서드를 호출할지 결정됩니다. 이것은 같은 인터페이스를 구현하거나 같은 클래스를 상속받은 다양한 객체들이 있을 때, 이들 객체를 동일한 방식으로 처리할 수 있게 해줍니다.

### 7. 인터페이스와 추상클래스의 차이점은 무엇일까요?

- **왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?**
- **인터페이스에서, `default method` 란 어떤 것인가요?**

### 8. A 라는클래스에 특정코드를 주고 싶을때, 상속과 조합의 차이는 무엇이고, 각각의 장점을 설명해주세요.

### 9. 리플렉션에 대해 설명해 주세요.

- **의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?**
- **리플렉션을 언제 활용할 수 있을까요?**

### 10. static class와 static method를 비교해 주세요.

- **static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?**
- **컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.**

### 11. 자바에서 `new` 키워드를 사용하면 어떤 일이 일어나나요? 메모리 관점에서 자세히 설명해주세요.

자바에서 `new` 키워드는
